<html>
<head>
    <title>Incremental</title>
    <style>
        sup,sub {
            font-size: 60%;
        }
    </style>
    <script type="text/javascript" id="util">
        $ = document.getElementById.bind(document);
        $$ = document.querySelectorAll.bind(document);
        function request(url, options) {
            options = options || {};
            var xhr = new XMLHttpRequest();
            // standard arguments get treated specially. here are their default values:
            var args = {
                method: 'GET',
                async: true,
                headers: {},
                body: null
            };
            // any additional options get set directly on xhr.
            // this allows the calling function to specify arbitrary parameters such as 'onload'.
            for (var i in options) {
                if (i in args) {
                    args[i] = options[i];
                }
                else {
                    xhr[i] = options[i];
                }
            }
            // serialize body as specified by Content-Type header
            if (args.body && typeof args.body !== 'string') {
                var contentType = args.headers['Content-Type'];
                if (contentType == 'application/json') {
                    args.body = JSON.stringify(args.body);
                } else if (contentType == 'application/x-www-form-urlencoded') {
                    args.body = serializeQuery(args.body);
                }
            }
            xhr.open(args.method, url, args.async);
            for (var name in args.headers) {
                var value = args.headers[name];
                xhr.setRequestHeader(name, value);
            }
            xhr.send(args.body);
            return xhr;
        }
        function serializeQuery(obj) {
            var pairs = [];
            for (var key in obj) {
                var value = obj[key];
                pairs.push(encodeURIComponent(key)+'='+encodeURIComponent(value));
            }
            return pairs.join('&').replace(/%20/g, '+')
        }
        function setText(field, value) {
            var props = ['value', 'textContent', 'innerText'];
            for (var i in props) {
                var prop = props[i];
                if (prop in field) {
                    field[prop] = value;
                    return
                }
            }
        }
        function render(template, context) {
            var container = document.createElement('div');
            var templateText = template.innerHTML || template;
            container.innerHTML = templateText.trim();
            var el = container.firstChild;
            for (var key in context) {
                var value = context[key];
                var selector = '[name="'+key+'"]';
                var fields = el.querySelectorAll(selector);
                for (var i = 0; i < fields.length; i++) {
                    var field = fields[i];
                    setText(field, value);
                }
            }
            return el;
        }
    </script>
    <script type="text/html" id="term-template">
        <span class="term">
            <span name="coefficient"></span><var name="variable"></var><sup name="exponent"></sup>
        </span>
    </script>
</head>
<body>
    <div style="position:fixed; top:0.5em; right:0.5em;">
        <span id="fps"></span> FPS
    </div>
    <p style="display:none;">
        Total frames: <span id="totalFrames"></span>
    </p>
    <p>
        Time on this page: <span id="timeOnPage">0</span> sec
    </p>
    <p>
        Clock skew: <span id="serverTime"></span> msec
        <button onclick="updateClockSkew()">update</button>
    </p>
    <p style="display: none;">
        Time since last click: <var>t</var> = <span id="timeSinceClick"></span> sec
        <button id="clickMe">click</button>
        Formula: <var>f</var>(<var>t</var>) = <span id="formula"></span>
        <button id="randomize-formula">randomize</button>
        <br>
        Value of formula: <span id="formula-value"></span>
    </p>
    <p style="line-height: 20px;">
        Accumulator start: <var>t<sub>0</sub></var> = <span id="accumulator-t0"></span>
        <br>
        Accumulator offset: <var>t</var> = <span id="accumulator-t"></span> sec
        <br>
        Accumulator formula: <var>f</var>(<var>t</var>) = <span id="accumulator-formula">0</span>
        <br>
        Continuous value: <span id="accumulator-value"></span>
        <br>
        Discrete value: <span id="accumulator-value-discrete"></span>
    </p>
    <p>
        <button id="add-one-per-second">Add 1 per second</button>
        <button id="add-one">Add 1</button>
        <button id="reset-accumulator">Reset</button>
    </p>
    <script>
        var clickTime = window.localStorage.getItem('clickTime') || Date.now();
        $('clickMe').onclick = function(){
            var now = Date.now();
            var serverNow = now - skew;
            // actually, we want to make sure skew is valid before using it
            clickTime = serverNow;
            window.localStorage.setItem('clickTime', clickTime);
        }

        var $timeOnPage = $('timeOnPage');
        var $fps = $('fps');
        var $totalFrames = $('totalFrames');
        var $timeSinceClick = $('timeSinceClick');
        var $formulaValue = $('formula-value');
        var startTime = Date.now();
        var lastFrame = startTime;
        var frameCount = 0;
        var totalFrames = 0;
        var targetFPS = 12;
        var msecPerFrame = 1000/targetFPS;
        function tick() {
            var now = Date.now();
            setText($timeOnPage, Math.floor((now - startTime)/1000));
            setText($totalFrames, ++totalFrames);

            var msecForThisFrame = now - lastFrame;
            lastFrame = now;

            msecPerFrame = (0.1 * msecForThisFrame) + (0.9 * msecPerFrame);
            setText($fps, Math.round(1000 / msecPerFrame));

            if (Math.abs(msecForThisFrame) > 1000/targetFPS + 100) {
                console.log('detected clock jump. reloading time from server.', msecForThisFrame);
                updateClockSkew();
            }


            var msecSinceClick = (now - clickTime - skew)
            setText($timeSinceClick, (msecSinceClick/100|0)/10);

            var value = evaluatePolynomial(polynomial, msecSinceClick/1000);
            setText($formulaValue, Math.floor(value));

            var accum_t = (now - accumulator.t_0 - skew)/1000;
            var accum_value = evaluatePolynomial(accumulator.k, accum_t);
            var accum_value_d = accumulator.evaluate(accum_t);
            setText($('accumulator-t'), accum_t);
            setText($('accumulator-value'), Math.floor(accum_value));
            setText($('accumulator-value-discrete'), Math.floor(accum_value_d));
        }

        var displayInterval = null;
        function setFPS(fps) {
            targetFPS = fps;
            clearInterval(displayInterval);
            displayInterval = setInterval(function(){
                requestAnimationFrame(tick);
            }, 1000/fps);
        }
        setFPS(targetFPS);

        var skew = null;
        function updateClockSkew(callback) {
            // TODO: support multiple callbacks waiting on the same request
            callback = callback || function(){};
            skew = null;
            var clientTime = Date.now();
            request(document.location, {
                method: 'HEAD',
                headers: {'Cache-Control': 'no-cache'},
                onload: function(){
                    if (skew != null || this.status == 0) {
                        return
                    }
                    var serverTime = new Date(this.getResponseHeader('date'));
                    // I don't think we have a way to tell how much time elapsed while the server was preparing the response.
                    skew = (Date.now()+clientTime)/2 - serverTime;
                    setText($('serverTime'), skew);
                    callback();
                }
            });
        };
        updateClockSkew();

        function displayPolynomial(coefficients, el, variable) {
            termTemplate = $('term-template').innerHTML;

            el.innerHTML = '';
            terms = [];
            for (var exp = coefficients.length-1; exp >= 0; exp--) {
                var k = coefficients[exp];
                var context = {};
                if (!k) {
                    continue;
                }
                if (k != 1 || exp == 0) {
                    context.coefficient = k;
                }
                if (exp> 0) {
                    context.variable = variable || 't';
                }
                if (exp> 1) {
                    context.exponent = exp;
                }
                var $term = render(termTemplate, context);
                terms.push($term);
            }
            if (terms.length == 0) {
                terms.push(render('0'));
            }
            for (var i = 0; i < terms.length; i++) {
                var $term = terms[i];
                if (i > 0) {
                    el.appendChild(render('+'));
                }
                el.appendChild($term);
            }
        }
        var polynomial = [];
        function randomizeFormula() {
            polynomial = [];
            for (var i = 0; i < 3; i++) {
                polynomial[i] = Math.random()*10|0;
            }
            displayPolynomial(polynomial, $('formula'));
        }
        $('randomize-formula').onclick = randomizeFormula;
        randomizeFormula();

        function evaluatePolynomial(coefficients, x) {
            var accum = 0;
            var x_to_exp = 1;
            for (var exp = 0; exp < coefficients.length; exp++) {
                var k_i = coefficients[exp] || 0;
                accum += k_i * x_to_exp;
                x_to_exp *= x;
            }
            return accum;
        }

        function Accumulator(properties) {
            this.trustClientClock = false;
            this.discrete = true;
            this.batched = false;
            this.scale = 1000;
            this.t_0 = Date.now();
            this.k = [];
            for (var i in properties) {
                this[i] = properties[i];
            }
        }

        // number of widgets at time t = edp(poly, t, 0)
        // number of widget factories at time t = edp(poly, t, 1)
        // number of manually-bought factories = poly[1]
        // TODO: do these equivalences still hold after translation?
        Accumulator.prototype.evaluate = function(x, i) {
            i = i || 0;
            if (i >= this.k.length) {
                return 0;
            }
            if (this.batched) {
                x = Math.floor(x);
            }
            var j = i + 1;
            var k_j = this.evaluate(x, j);
            var k_i = this.k[i] + k_j*x;
            if (this.discrete) {
                return Math.floor(k_i);
            }
            else {
                return k_i;
            }
        };

        // general-purpose function to translate a polynomial from t_0 to t_1
        // TODO: determine whether this method can accommodate higher-order polynomials
        // f(t) = a * t^2 + b * t + c
        // f(t-t_0) = a*(t-t_0)^2 + b*(t-t_0) + c
        //          = a*(t^2 - 2*t_0*t + t_0^2) + b*t - b*t_0 + c
        //          = a*t^2 - (2*a*t_0 + b)*t + a*t_0^2 - b*t_0 + c
        // is t_0^2 meaningful?
        Accumulator.prototype.translate = function(t_1) {
            var newPoly = [];
            for (var i = 0; i < this.k.length; i++) {
                // TODO: support higher order translation
                newPoly[i] = this.k[i];
            }
            var t = (t_1-this.t_0)/this.scale;
            newPoly[0] = this.evaluate(t);
            this.k = newPoly;
            this.t_0 = t_1;
        };

        // would like to support negative mods with floors
        // eg consume materials to produce products,
        // without going below zero
        Accumulator.prototype.addPolynomial = function(mod) {
            if (skew == null && !this.trustClientClock) {
                var that = this;
                updateClockSkew(function(){
                    that.addPolynomial(mod);
                });
            }
            else {
                var t_1 = Date.now() - skew;
                this.translate(t_1);
                mod = mod || [];
                for (var i = 0; i < mod.length; i++) {
                    this.k[i] = (this.k[i] || 0) + mod[i];
                }
                // this.save();
            }
        };

        Accumulator.prototype.save = function() {
            // TBD
        };

        var accumulator = new Accumulator();
        try {
            data = JSON.parse(localStorage.getItem('accumulator'));
            accumulator = new Accumulator(data);
        }
        catch (e) {}

        function saveAccumulator() {
            localStorage.setItem('accumulator', JSON.stringify(accumulator));
            displayPolynomial(accumulator.k, $('accumulator-formula'));
            setText($('accumulator-t0'), new Date(accumulator.t_0));
        }
        saveAccumulator();


        $("add-one").onclick = function() {
            accumulator.addPolynomial([1]);
            saveAccumulator();
        };
        $("add-one-per-second").onclick = function() {
            accumulator.addPolynomial([0,1]);
            saveAccumulator();
        };
        $("reset-accumulator").onclick = function() {
            accumulator.t_0 = Date.now() - skew;
            accumulator.poly = [];
            saveAccumulator();
        };

    </script>
    <script src="/bundle.js"></script>
</body>
